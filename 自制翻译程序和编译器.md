**interpreter** 或者一个**compiler**的目标是将源程序转换为高级语言，转换为其他的形式。听起来很迷惑，对吧？耐心等待，接下来的一系列你将学到源程序被转换成了什么。



同时你也可能好奇**interpreter** 和**compiler**有什么区别，

我们认为如果一个转换器，它将源程序转换为机器语言，他就是compiler；

如果一个转换器在转换为机器语言之前就处理并执行了源程序，那他就是interpreter；

它们看起来是这样：

![image-20210123210210971](C:\Users\00\AppData\Roaming\Typora\typora-user-images\image-20210123210210971.png)



![image-20210123210224319](C:\Users\00\AppData\Roaming\Typora\typora-user-images\image-20210123210224319.png)

我希望你现在真的确信想要学习如何构建interpreter和compiler，你对这一系列的interpreters有什么期待？

这里有一个主意，你和我将要为Pascal语言创建一个简单的interpreter，在系列文章的最后我们会完成一个Pascal的子集的interpreter和一个源代码级别的debugger，就像Python的pdb



你可能会问，什么是Pascal？他不是我杜撰出来的语言，而是一个真实存在的，有很多重要语言结构的语言。同时，很多旧的但是很重要的cs教材都是用Pascal语言多为案例，我知道这不是一个让人信服的理由去选择它，但是我认为他是一个好的学习非主流语言的机会



这是一个Pascal的阶乘函数的例子，你可以用自己的interpreter去interpret它，还可以用交互式的源代码级调试器进行debugger



Pascal解释器的实现语言可以是Python，但是你也可以用任何你想要的语言完成它，因为提出的想法不依赖于任何语言实现。



第一部的目标是实现一个简单的对算术表达式进行解释的，就像一个计算器。

今天的目标是非常小的，实现一个计算处理器，去讲两个整数相加，例如3+5。这里是你的解释器的源码：



在你准备深挖代码之前，在命令行运行计算器可以看到他的行为。玩一玩吧！

