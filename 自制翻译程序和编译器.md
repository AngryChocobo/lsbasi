**interpreter** 或者一个**compiler**的目标是将源程序转换为高级语言，转换为其他的形式。听起来很迷惑，对吧？耐心等待，接下来的一系列你将学到源程序被转换成了什么。

同时你也可能好奇**interpreter** 和**compiler**有什么区别，

我们认为如果一个转换器，它将源程序转换为机器语言，他就是 compiler；

如果一个转换器在转换为机器语言之前就处理并执行了源程序，那他就是 interpreter；

它们看起来是这样：

![image-20210123210210971](C:\Users\00\AppData\Roaming\Typora\typora-user-images\image-20210123210210971.png)

![image-20210123210224319](C:\Users\00\AppData\Roaming\Typora\typora-user-images\image-20210123210224319.png)

我希望你现在真的确信想要学习如何构建 interpreter 和 compiler，你对这一系列的 interpreters 有什么期待？

这里有一个主意，你和我将要为 Pascal 语言创建一个简单的 interpreter，在系列文章的最后我们会完成一个 Pascal 的子集的 interpreter 和一个源代码级别的 debugger，就像 Python 的 pdb

你可能会问，什么是 Pascal？他不是我杜撰出来的语言，而是一个真实存在的，有很多重要语言结构的语言。同时，很多旧的但是很重要的 cs 教材都是用 Pascal 语言多为案例，我知道这不是一个让人信服的理由去选择它，但是我认为他是一个好的学习非主流语言的机会

这是一个 Pascal 的阶乘函数的例子，你可以用自己的 interpreter 去 interpret 它，还可以用交互式的源代码级调试器进行 debugger

Pascal 解释器的实现语言可以是 Python，但是你也可以用任何你想要的语言完成它，因为提出的想法不依赖于任何语言实现。

第一部的目标是实现一个简单的对算术表达式进行解释的，就像一个计算器。

今天的目标是非常小的，实现一个计算处理器，去讲两个整数相加，例如 3+5。这里是你的解释器的源码：

在你准备深挖代码之前，在命令行运行计算器可以看到他的行为。玩一玩吧！

为了让你的简单计算器在不报错情况下正常工作，你的输入必须符合以下规则：

- 只能输入一位整数
- 现在唯一支持的算术运算是加法
- 输入的任何位置都不允许插入空格

这些限制条件对于让计算器简单来说是必要的。别担心，你接下来会让它变得非常复杂。
让我们来分解他，看看他是如何计算出算术表达式的。
当你在命令行输入了 3+5，你的解释程序就得到了一个字符串"3+5"，
为了让解释程序真的知道如何处理字符串，首先要将输入拆分成名为"token"的组件，token 是包含 type 和 value 的对昂。
例如，字符串 3 的 type 会是"INTEGER"，value 是整形 3。
将字符串分解为 token 的过程称为 lexical analysis，词法分析。所以，我们的第一步需要读取输出，转化为 token 的流，解释器执行此操作的部分称为词法分析器，简称词法分析器。你也可能遇到过它的其他名字，叫 scanner 或者 tokenizer。他们的意思都是一样的：interpreter 或 compiler 中将输入的字符转换成 token 流的那部分

在 Interpreter 类中的 get_next_token 方法就是你的词法分析器。每当你调用它时，将会以解释程序的输入字符创建一个新的 token。让我们进入函数中看看它是如何做的。输入被存储在 text 的变量中，值为字符串的 pos 位置上的字符。pos 的初始值为 0，所以取到的字符是'3'。函数先判断是否字符是一个数字，如果是，就将 pos 增加 1，并返回值为 3,类型为 INTEGER 的 token。
pos 所指向的下一个字符是'+',下次调用这个方法时，他会判断字符是数字还是加号。类似的，函数将创建一个 type 为 PLUS，值为'+'的 token 作为返回值。

pos 所指向的下一个字符是'5'，当你再次调用这个函数时，他依旧返回了 INTEGER 的 token。
因为现在 pos 指向的 index 已经超出了输入字符'3+5'的长度，所以每次调用函数，都会返回 EOF 的 Token。
到现在为止，你的解释程序已经可以从输入字符串生成的 token 流中获取，解释程序试图找到这样的序列结构：：整数，后跟加号，后跟整数。
负责查找和解释这个结构的函数是 expr。它校验 token 的序列是否确实与预期的 token 序列对应。如果成功校验了结构序列，他就会将左值和右值相加作为结果返回，这样成功就成功地解释了你输入的算术运算符。

expr 函数用了一个名为 eat 的辅助函数来校验传入的 token type 和当前的 token type 是否对应。
传递了 token type 后，eat 函数会调用 get_next_token 并将返回值赋给 current_token，像是吃掉了当前令牌，并将指针向后移动（其实没有指针）。

如果 token 流中的结构和预期不一致，则报错。

总结一下解释程序处理算术表达式的流程：

1. 解释程序接受了'3+5'的输入字符串

2.解释程序调用 expr 函数来从 token 流中寻找语法分析的结构，试图找到 INTEEGER PLUS INTEGER 的序列。 确认结构后，它会通过添加两个 INTEGER 令牌的值来解释输入，因为此时解释器很清楚，它需要做的是添加两个整数 3 和 5。

恭喜你，现在你学会了构建你自己的第一个解释器，您认为您不会之阅读这篇文章就够了吧，对吗？那么我们来练习一下：

1. 修改程序，支持多位的数字输入，比如'12+3'

2. 增加一个可以跳过空格的函数，使其可以处理' 12 + 3'

3. 修改代码，用加法替代减法去处理'7-5'

## 检查一下你的理解

1. 什么是 interpreter?

2. 什么是 compiler?

3. interpreter 和 compiler 的区别？

4. 什么是 token？

5. 将输入切分为 tokens 的程序是什么？

6. 做词法分析的部分叫什么？

7. interpreter 或 compiler 还是什么常见的名字？

在完成这篇文章之前，我真的希望你完成自己的 interpreters 和 compilers。并且希望现在就开始，而不是扔进收藏夹。不要等待，
